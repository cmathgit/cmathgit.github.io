<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flocking Boids Animation</title>
    <style>
        /* Basic page setup */
        body {
            margin: 0;
            overflow: hidden;
            height: 100vh;
            /* background-image: url('./image_2025-04-11_04-15-13.png'); */ /* Remove this line */
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            /* Add a transition for smoother background change */
            transition: background-image 1s ease-in-out;
            /* Optional: Set a default background color while images load */
            background-color: #223344;
        }

        /* Container for all boids */
        #boid-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* Wrapper for each boid (bird + ring) */
        .boid-wrapper {
            position: absolute;
            /* Base size for followers */
            width: 70px;
            height: 70px;
             /* Center the bird/ring within the wrapper for easier positioning */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Style for the inner 'bird' element */
        .boid-bird {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            position: absolute; /* Position relative to wrapper */
            z-index: 10;
            /* background-color set by JS */
            /* Add overflow hidden if eyes/mouth risk going outside on sharp turns */
            /* overflow: hidden; */
            /* Ensure relative positioning for face elements */
            position: relative;
            display: flex; /* Use flex to help center if needed, though absolute positioning is primary */
            justify-content: center;
            align-items: center;
        }

        /* Style for the inner 'ring' element */
        .boid-ring {
            width: 70px;
            height: 70px;
            border: 3px solid transparent;
            border-top: 3px solid red; /* Default ring color */
            border-radius: 50%;
            position: absolute; /* Position relative to wrapper */
            transform-origin: center center;
            transition: transform 0.1s linear; /* Smooth rotation update */
            z-index: 9; /* Ensure ring is behind bird face */
        }

         /* --- Leader Styles --- */
        .boid-wrapper.leader {
            /* Make leader wrapper larger */
            width: 105px; /* 1.5x */
            height: 105px;
        }
        .boid-wrapper.leader .boid-bird {
            /* Make leader bird larger */
            width: 75px; /* 1.5x */
            height: 75px;
            z-index: 11; /* Ensure leader bird is on top */
        }
         .boid-wrapper.leader .boid-ring {
            /* Make leader ring larger and different color */
            width: 105px; /* 1.5x */
            height: 105px;
            border-top-color: gold; /* Leader ring color */
         }

        /* --- Face Element Styles --- */
        .boid-eye {
            position: absolute;
            width: 12%; /* Relative size */
            height: 16%; /* Slightly oval */
            background-color: #111; /* Darker eye color */
            border-radius: 50%;
            top: 35%; /* Position eyes vertically */
            z-index: 11; /* Above bird background */
        }
        .boid-eye-left {
            left: 28%; /* Position left eye */
            transform: translateX(-50%) rotate(-15deg); /* Slight inward tilt */
        }
        .boid-eye-right {
            right: 28%; /* Position right eye */
            transform: translateX(50%) rotate(15deg); /* Slight inward tilt */
        }
        .boid-mouth {
            position: absolute;
            width: 40%; /* Mouth width */
            height: 20%; /* Mouth height (adjusts curve) */
            bottom: 20%; /* Position mouth vertically */
            left: 50%;
            transform: translateX(-50%);
            border-style: solid;
            border-color: #111; /* Dark mouth color */
            border-width: 0; /* Base border width */
            border-radius: 0; /* Base border radius */
            box-sizing: border-box;
            z-index: 11; /* Above bird background */
        }

         /* --- Expression Styles --- */
         /* Neutral Expression */
        .boid-expression-neutral .boid-mouth {
            border-bottom-width: 2px; /* Flat line */
            height: 0; /* Reduce height for flat line */
            bottom: 25%;
         }
          /* Leader Expression Adjustments */
         .leader .boid-expression-neutral .boid-mouth {
             border-bottom-width: 3px; /* Thicker line for leader */
         }


         /* Happy Expression */
        .boid-expression-happy .boid-mouth {
            border-bottom-width: 2px; /* Curve on bottom */
            border-radius: 0 0 50% 50% / 0 0 100% 100%; /* U-shape curve */
            border-top-width: 0;
        }
         /* Leader Expression Adjustments */
         .leader .boid-expression-happy .boid-mouth {
             border-bottom-width: 3px; /* Thicker curve for leader */
         }

         /* Sad Expression */
         .boid-expression-sad .boid-mouth {
            border-top-width: 2px; /* Curve on top */
            border-radius: 50% 50% 0 0 / 100% 100% 0 0; /* Inverse U-shape curve */
            border-bottom-width: 0;
            height: 20%; /* Need height for top curve */
            bottom: 28%; /* Adjust position slightly for top curve */
        }
         /* Leader Expression Adjustments */
         .leader .boid-expression-sad .boid-mouth {
             border-top-width: 3px; /* Thicker curve for leader */
         }

        /* --- Progress Bar Styles --- */
        #leader-progress-bar {
            position: fixed;
            bottom: 15px; /* Lower position */
            left: 50%;    /* Start at center */
            transform: translateX(-50%); /* Center horizontally */
            width: 80%;   /* Width of the bar */
            max-width: 600px; /* Max width */
            height: 20px;  /* Height of the bar */
            border: 1px solid #ccc;
            border-radius: 10px;
            overflow: hidden; /* Clip inner bars */
            display: flex;    /* Arrange inner bars horizontally */
            background-color: hsl(120, 50%, 50%); /* Default/Neutral background (Greenish) */
            transition: background-color 0.5s ease; /* Smooth background color transition */
            z-index: 20; /* Ensure it's above boids */
        }

        #progress-red, #progress-blue {
            height: 100%;
            transition: width 0.5s ease; /* Smooth width transition */
        }

        #progress-red {
            background-color: hsl(0, 100%, 50%); /* Red */
        }

        #progress-blue {
            background-color: hsl(240, 100%, 50%); /* Blue */
        }

        /* --- Controls Styles --- */
        #controls-container {
            position: fixed;
            bottom: 50px; /* Above progress bar */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.75);
            color: #eee;
            padding: 10px;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap; /* Allow controls to wrap on smaller screens */
            gap: 10px 20px;  /* Row gap, Column gap */
            justify-content: center;
            align-items: flex-start; /* Align items to top */
            font-family: Arial, sans-serif;
            font-size: 11px; /* Smaller font */
            z-index: 25; /* Above progress bar */
            max-width: 95%;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .control-item { /* Styles for the Perception slider */
             display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px; /* Add some space below slider */
        }
         /* Common styles for 2D control areas */
        .control-area {
            width: 120px; /* Control area size */
            height: 120px;
            border: 1px solid #888;
            background-color: rgba(255, 255, 255, 0.1);
            cursor: crosshair;
            position: relative; /* For positioning labels/values/indicator */
            display: flex;
            flex-direction: column; /* Stack label, axes, values */
            padding: 4px;
            box-sizing: border-box;
            border-radius: 4px;
        }
        .control-area-label {
            font-weight: bold;
            text-align: center;
            font-size: 10px;
            margin-bottom: 4px;
            color: #fff;
        }
         .control-area-axes {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #ccc;
            padding: 0 2px;
            margin-bottom: 4px;
         }
        .control-area-values {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            font-family: monospace;
             margin-top: auto; /* Push values to the bottom */
             padding: 0 2px;
        }
        .control-indicator {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(255, 0, 0, 0.7); /* Red indicator */
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.5);
            pointer-events: none; /* Don't let it interfere with mouse events */
            transform: translate(-50%, -50%); /* Center on position */
             /* Initial position will be set by JS */
        }

        /* Remove styles for old individual items if they conflict */
        /* .control-item label { ... } */
        /* .control-item input[type="range"] { ... } */
        /* .control-item .value { ... } */

        .control-note {
            width: 100%; /* Take full width */
            text-align: center;
            font-size: 10px;
            color: #aaa;
            margin-top: 10px; /* Adjust spacing */
        }
    </style>
</head>
<body>

    <div id="boid-container">
        <!-- Boids will be added here dynamically by JavaScript -->
    </div>

    <!-- Audio Elements for Background Music -->
    <audio id="music-day" src="./boidstory.mp3" loop></audio>
    <audio id="music-night" src="./incandescent house.mp3" loop></audio>

    <!-- Control Sliders -->
    <div id="controls-container">
        <!-- Perception Slider (Remains) -->
        <div class="control-item control-slider">
            <label for="perception">Perception:</label>
            <input type="range" id="perception" name="perception">
            <span class="value" id="perception-value"></span>
        </div>

        <!-- 2D Control Area 1: Flock Shape -->
        <div class="control-area" id="control-flock-shape">
            <div class="control-area-label">Flock Shape</div>
            <div class="control-area-axes">
                <span class="axis-label">X: Align</span>
                <span class="axis-label">Y: Cohesion</span>
            </div>
            <div class="control-area-values">
                <span class="value" id="alignment-value"></span>
                <span class="value" id="cohesion-value"></span>
            </div>
            <!-- Add a small indicator dot if desired -->
            <div class="control-indicator" id="indicator-flock-shape"></div>
        </div>

        <!-- 2D Control Area 2: Forces -->
        <div class="control-area" id="control-forces">
            <div class="control-area-label">Forces</div>
             <div class="control-area-axes">
                <span class="axis-label">X: Separation</span>
                <span class="axis-label">Y: Max Force</span>
            </div>
             <div class="control-area-values">
                <span class="value" id="separation-value"></span>
                <span class="value" id="max-force-value"></span>
            </div>
             <div class="control-indicator" id="indicator-forces"></div>
        </div>

        <!-- 2D Control Area 3: Speed/Follow -->
        <div class="control-area" id="control-speed-follow">
             <div class="control-area-label">Speed/Follow</div>
             <div class="control-area-axes">
                <span class="axis-label">X: Max Speed</span>
                <span class="axis-label">Y: Follow Ldr</span>
            </div>
             <div class="control-area-values">
                <span class="value" id="max-speed-value"></span>
                <span class="value" id="leader-follow-value"></span>
            </div>
            <div class="control-indicator" id="indicator-speed-follow"></div>
        </div>

        <!-- Note (Remains) -->
        <div class="control-note">
            Note: Change NUM_BOIDS in script & refresh for effect.
        </div>
    </div>

    <!-- Progress Bar Elements -->
    <div id="leader-progress-bar">
        <div id="progress-red"></div>
        <div id="progress-blue"></div>
    </div>

    <script>
        // Parameters
        const NUM_BOIDS = 100;
        let PERCEPTION_RADIUS = 80;
        let MAX_SPEED = 4.0;
        let MAX_FORCE = 0.1;
        let LEADER_MAX_SPEED = 3.0;
        let SEPARATION_WEIGHT = 1.8;
        let ALIGNMENT_WEIGHT = 1.0;
        let COHESION_WEIGHT = 0.9;
        let LEADER_FOLLOW_WEIGHT = 1.5;
        const LEADER_HUE_0 = 0;     // Red
        const LEADER_HUE_1 = 240;   // Blue
        const LEADER_HUE_2 = 120;   // Green (Added)
        const DEFAULT_FOLLOWER_HUE = 180; // Slightly different default (e.g., cyan)
        let LEADER_REPULSION_WEIGHT = 2.5; // Added: How strongly the green leader avoids others

        // *** Background Image Settings ***
        const BACKGROUND_IMAGES = [
            './image_2025-04-11_03-58-24.png',    // DAY image (index 0)
            './image_2025-04-11_04-15-13.png'  // NIGHT image (index 1)
        ];
        const BACKGROUND_SWITCH_INTERVAL_MS = 150000; // Switch every 30 seconds
        let currentBackgroundIndex = 0; // Start with day (index 0)
        // *** End Background Image Settings ***

        // Vector Math (Unchanged)
        const Vector = {
            magnitude: (v) => Math.sqrt(v.x * v.x + v.y * v.y),
            limit: (v, max) => {
                const magSq = v.x * v.x + v.y * v.y;
                if (magSq > max * max && max > 0) { // Added check for max > 0
                    const mag = Math.sqrt(magSq);
                    v.x = (v.x / mag) * max;
                    v.y = (v.y / mag) * max;
                }
                return v;
            },
            normalize: (v) => {
                const mag = Vector.magnitude(v);
                if (mag > 0) {
                    v.x /= mag;
                    v.y /= mag;
                }
                return v;
            },
            subtract: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }),
            add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }),
            multiply: (v, scalar) => ({ x: v.x * scalar, y: v.y * scalar }),
            divide: (v, scalar) => (scalar !== 0 ? { x: v.x / scalar, y: v.y / scalar } : {x: 0, y: 0})
        };

        // Boid Class
        class Boid {
            constructor(x, y, wrapperElement, isLeader = false) {
                this.element = wrapperElement;
                this.birdElement = this.element.querySelector('.boid-bird');
                this.ringElement = this.element.querySelector('.boid-ring');
                // *** Add Face References ***
                this.faceElements = {
                     eyes: this.birdElement.querySelectorAll('.boid-eye'),
                     mouth: this.birdElement.querySelector('.boid-mouth')
                };
                // *** End Face References ***

                this.isLeader = isLeader;
                this.leaderIndex = -1;
                this.hue = 0;

                this.width = isLeader ? 105 : 70;
                this.height = isLeader ? 105 : 70;

                this.position = { x, y };
                this.velocity = {
                    x: Math.random() * 4 - 2 || 0.1, // Ensure non-zero x initially
                    y: Math.random() * 4 - 2 || 0.1  // Ensure non-zero y initially
                };
                 // Re-check magnitude just in case both were 0 before || 0.1
                if (Vector.magnitude(this.velocity) === 0) this.velocity = { x: 1, y: 0 };

                this.acceleration = { x: 0, y: 0 };

                 // Use the dynamic variables here
                this.maxSpeed = this.isLeader ? LEADER_MAX_SPEED : MAX_SPEED;
                this.maxForce = MAX_FORCE;
            }

            // --- Flocking Methods ---
            calculateFlockingForces(boids) {
                let separation = { x: 0, y: 0 };
                let alignment = { x: 0, y: 0 };
                let cohesion = { x: 0, y: 0 };
                let neighborCount = 0;

                boids.forEach(other => {
                    // Calculate distance using Pythagorean theorem directly for performance
                    const dx = this.position.x - other.position.x;
                    const dy = this.position.y - other.position.y;
                    const dSq = dx * dx + dy * dy; // Use squared distance for comparison

                    // Check if within perception radius (and not self)
                    if (dSq > 0 && dSq < PERCEPTION_RADIUS * PERCEPTION_RADIUS) {
                        const d = Math.sqrt(dSq); // Calculate actual distance only if needed
                        neighborCount++;

                        // Separation: Vector pointing away from neighbor, weighted inversely by distance
                        let diff = { x: dx, y: dy };
                        Vector.normalize(diff);
                        Vector.divide(diff, d); // Weight by distance
                        separation = Vector.add(separation, diff);

                        // Alignment: Sum neighbors' velocities
                        alignment = Vector.add(alignment, other.velocity);

                        // Cohesion: Sum neighbors' positions
                        cohesion = Vector.add(cohesion, other.position);
                    }
                });

                let steer = { x: 0, y: 0 }; // Total steering force

                if (neighborCount > 0) {
                    // Average and calculate steering vectors
                    separation = Vector.divide(separation, neighborCount);
                    alignment = Vector.divide(alignment, neighborCount);
                    cohesion = Vector.divide(cohesion, neighborCount);

                    // --- Finalize Separation Steering ---
                    if (Vector.magnitude(separation) > 0) { // Avoid normalizing zero vector
                        Vector.normalize(separation);
                        separation = Vector.multiply(separation, this.maxSpeed);
                        let separationSteer = Vector.subtract(separation, this.velocity);
                        Vector.limit(separationSteer, this.maxForce);
                        steer = Vector.add(steer, Vector.multiply(separationSteer, SEPARATION_WEIGHT));
                    }

                    // --- Finalize Alignment Steering ---
                    if (Vector.magnitude(alignment) > 0) {
                        Vector.normalize(alignment);
                        alignment = Vector.multiply(alignment, this.maxSpeed);
                        let alignmentSteer = Vector.subtract(alignment, this.velocity);
                        Vector.limit(alignmentSteer, this.maxForce);
                         steer = Vector.add(steer, Vector.multiply(alignmentSteer, ALIGNMENT_WEIGHT));
                    }

                    // --- Finalize Cohesion Steering (Seek center of mass) ---
                    let desiredCohesion = Vector.subtract(cohesion, this.position);
                    if (Vector.magnitude(desiredCohesion) > 0) {
                        Vector.normalize(desiredCohesion);
                        desiredCohesion = Vector.multiply(desiredCohesion, this.maxSpeed);
                        let cohesionSteer = Vector.subtract(desiredCohesion, this.velocity);
                        Vector.limit(cohesionSteer, this.maxForce);
                        steer = Vector.add(steer, Vector.multiply(cohesionSteer, COHESION_WEIGHT));
                    }
                }
                return steer; // Return the combined flocking force
            }

            followLeaderForce(leader) {
                 if (!leader) return { x: 0, y: 0 }; // No leader, no force

                 let desired = Vector.subtract(leader.position, this.position);
                 const d = Vector.magnitude(desired);

                 // Optional: If close enough, maybe slow down or apply less force
                 // if (d < someStopRadius) { return {x:0, y:0}; }

                 if (d > 0) {
                     Vector.normalize(desired);
                     desired = Vector.multiply(desired, this.maxSpeed);
                     let steer = Vector.subtract(desired, this.velocity);
                     Vector.limit(steer, this.maxForce);
                     return Vector.multiply(steer, LEADER_FOLLOW_WEIGHT);
                 }
                 return { x: 0, y: 0 };
            }

            // *** Add Leader Repulsion Method ***
            calculateLeaderRepulsionForce(otherLeaders) {
                let repulsionForce = { x: 0, y: 0 };
                let closeLeadersCount = 0;
                const repulsionRadiusSq = PERCEPTION_RADIUS * PERCEPTION_RADIUS * 1.5 * 1.5; // Larger radius for repulsion

                otherLeaders.forEach(otherLeader => {
                    if (otherLeader === this) return; // Don't repel self

                    const dx = this.position.x - otherLeader.position.x;
                    const dy = this.position.y - otherLeader.position.y;
                    const dSq = dx * dx + dy * dy;

                    // Check if within repulsion radius
                    if (dSq > 0 && dSq < repulsionRadiusSq) {
                        const d = Math.sqrt(dSq);
                        closeLeadersCount++;

                        // Force pointing away from the other leader, stronger when closer
                        let diff = { x: dx, y: dy };
                        Vector.normalize(diff);
                        Vector.divide(diff, d); // Weight inversely by distance
                        repulsionForce = Vector.add(repulsionForce, diff);
                    }
                });

                let steer = { x: 0, y: 0 };
                if (closeLeadersCount > 0) {
                    // Average the repulsion vectors
                    repulsionForce = Vector.divide(repulsionForce, closeLeadersCount);

                    // Steer away
                    if (Vector.magnitude(repulsionForce) > 0) {
                        Vector.normalize(repulsionForce);
                        repulsionForce = Vector.multiply(repulsionForce, this.maxSpeed); // Desired velocity is max speed away
                        steer = Vector.subtract(repulsionForce, this.velocity);
                        Vector.limit(steer, this.maxForce); // Limit the steering force
                    }
                }
                // Apply the weight
                return Vector.multiply(steer, LEADER_REPULSION_WEIGHT);
            }
            // *** End Leader Repulsion Method ***

            // --- Core Boid Methods ---
            applyForce(force) {
                // Add force to acceleration (assume mass = 1)
                this.acceleration = Vector.add(this.acceleration, force);
            }

            calculateSeekForce(target) {
                let desired = Vector.subtract(target, this.position);
                Vector.normalize(desired);
                desired = Vector.multiply(desired, this.maxSpeed);
                let steer = Vector.subtract(desired, this.velocity);
                Vector.limit(steer, this.maxForce);
                return steer;
            }

            update() {
                // Update velocity from acceleration
                this.velocity = Vector.add(this.velocity, this.acceleration);
                // Limit velocity
                Vector.limit(this.velocity, this.maxSpeed);

                // Update position from velocity
                this.position = Vector.add(this.position, this.velocity);

                // Reset acceleration for next frame
                this.acceleration = { x: 0, y: 0 };
            }

            checkEdges() {
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const buffer = 5;

                let bounced = false;
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;

                if (this.position.x + halfWidth > viewportWidth) {
                    this.position.x = viewportWidth - halfWidth - buffer;
                    this.velocity.x *= -1;
                    bounced = true;
                } else if (this.position.x - halfWidth < 0) {
                    this.position.x = halfWidth + buffer;
                    this.velocity.x *= -1;
                    bounced = true;
                }

                if (this.position.y + halfHeight > viewportHeight) {
                    this.position.y = viewportHeight - halfHeight - buffer;
                    this.velocity.y *= -1;
                    bounced = true;
                } else if (this.position.y - halfHeight < 0) {
                    this.position.y = halfHeight + buffer;
                    this.velocity.y *= -1;
                    bounced = true;
                }
            }

            // Update the DOM element's position
            display() {
                 // Position the wrapper based on the boid's center
                this.element.style.left = `${this.position.x - this.width / 2}px`;
                this.element.style.top = `${this.position.y - this.height / 2}px`;

                // Update ring rotation based on velocity
                if (this.ringElement) {
                    // Calculate angle from velocity vector (in radians)
                    const angleRad = Math.atan2(this.velocity.y, this.velocity.x);
                    // Convert to degrees and add 90 degree offset because border-top points up
                    const angleDeg = angleRad * (180 / Math.PI) + 90;
                    // Apply rotation
                    this.ringElement.style.transform = `rotate(${angleDeg}deg)`;
                }
            }
        }

        // Find Nearest Leader (Unchanged)
        function findNearestLeader(followerBoid, allLeaders) {
            let nearestLeader = null;
            let minDistanceSq = Infinity; // Use squared distance for efficiency

            allLeaders.forEach(leader => {
                const dx = followerBoid.position.x - leader.position.x;
                const dy = followerBoid.position.y - leader.position.y;
                const dSq = dx * dx + dy * dy;

                if (dSq < minDistanceSq) {
                    minDistanceSq = dSq;
                    nearestLeader = leader;
                }
            });
            return nearestLeader; // Returns the closest leader object or null if no leaders
        }

        // Mouse Tracking (Unchanged)
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        window.addEventListener('mousemove', (event) => {
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        // --- Control Area Setup ---
        const controlAreas = {
            flockShape: document.getElementById('control-flock-shape'),
            forces: document.getElementById('control-forces'),
            speedFollow: document.getElementById('control-speed-follow'),
        };
        const indicators = {
            flockShape: document.getElementById('indicator-flock-shape'),
            forces: document.getElementById('indicator-forces'),
            speedFollow: document.getElementById('indicator-speed-follow'),
        };
        const valueDisplays = {
            perception: document.getElementById('perception-value'),
            alignment: document.getElementById('alignment-value'),
            cohesion: document.getElementById('cohesion-value'),
            separation: document.getElementById('separation-value'),
            maxForce: document.getElementById('max-force-value'),
            maxSpeed: document.getElementById('max-speed-value'),
            leaderFollow: document.getElementById('leader-follow-value'),
        };
        // Perception slider remains separate
        const perceptionSlider = document.getElementById('perception');

        let activeControlArea = null; // Track which area is being dragged

        // Helper function to map a value from one range to another
        function mapRange(value, inMin, inMax, outMin, outMax) {
            // Clamp value to input range first
            const clampedValue = Math.max(inMin, Math.min(value, inMax));
            return outMin + (outMax - outMin) * (clampedValue - inMin) / (inMax - inMin);
        }

        // Function to update parameters based on mouse position within an area
        function updateControlArea(areaElement, event) {
            if (!areaElement) return;

            const rect = areaElement.getBoundingClientRect();
            // Calculate mouse position relative to the control area, clamp to bounds
            let x = Math.max(0, Math.min(event.clientX - rect.left, rect.width));
            let y = Math.max(0, Math.min(event.clientY - rect.top, rect.height));

            // Invert Y because screen coordinates increase downwards
            const normalizedY = 1 - (y / rect.height);
            const normalizedX = x / rect.width;

             // Update indicator position
             const indicator = indicators[areaElement.id.replace('control-', '')];
             if (indicator) {
                 indicator.style.left = `${x}px`;
                 indicator.style.top = `${y}px`;
             }


            // Update parameters based on which control area it is
            switch (areaElement.id) {
                case 'control-flock-shape':
                    ALIGNMENT_WEIGHT = mapRange(normalizedX, 0, 1, -3.0, 3.0);
                    COHESION_WEIGHT = mapRange(normalizedY, 0, 1, -3.0, 3.0);
                    valueDisplays.alignment.textContent = ALIGNMENT_WEIGHT.toFixed(1);
                    valueDisplays.cohesion.textContent = COHESION_WEIGHT.toFixed(1);
                    break;
                case 'control-forces':
                    SEPARATION_WEIGHT = mapRange(normalizedX, 0, 1, -3.0, 3.0);
                    MAX_FORCE = mapRange(normalizedY, 0, 1, 0.01, 0.5);
                    valueDisplays.separation.textContent = SEPARATION_WEIGHT.toFixed(1);
                    valueDisplays.maxForce.textContent = MAX_FORCE.toFixed(2);
                    // Update existing boids
                    boids.forEach(b => b.maxForce = MAX_FORCE);
                    break;
                case 'control-speed-follow':
                    MAX_SPEED = mapRange(normalizedX, 0, 1, 0.5, 10.0);
                    LEADER_FOLLOW_WEIGHT = mapRange(normalizedY, 0, 1, 0, 4.0);
                    valueDisplays.maxSpeed.textContent = MAX_SPEED.toFixed(1);
                    valueDisplays.leaderFollow.textContent = LEADER_FOLLOW_WEIGHT.toFixed(1);
                     // Update existing boids
                     boids.forEach(b => { if (!b.isLeader) b.maxSpeed = MAX_SPEED; });
                    break;
            }
        }

         // --- Event Listeners for Control Areas ---

         // Listener added to window during drag
         const handleWindowMouseMove = (event) => {
             if (activeControlArea) {
                 updateControlArea(activeControlArea, event);
             }
         };

         // Listener added to window during drag
         const handleWindowMouseUp = () => {
             activeControlArea = null;
             window.removeEventListener('mousemove', handleWindowMouseMove);
             window.removeEventListener('mouseup', handleWindowMouseUp);
         };

         // Add listeners to each control area
         Object.values(controlAreas).forEach(area => {
             area.addEventListener('mousedown', (event) => {
                 activeControlArea = event.currentTarget; // The area div
                 updateControlArea(activeControlArea, event); // Update on initial click
                 // Add listeners to window to handle dragging outside the area
                 window.addEventListener('mousemove', handleWindowMouseMove);
                 window.addEventListener('mouseup', handleWindowMouseUp);
             });
              // Also update on move within the area if mouse button is down
             area.addEventListener('mousemove', (event) => {
                 if (activeControlArea === event.currentTarget) {
                     updateControlArea(activeControlArea, event);
                 }
             });
             // Optional: Handle mouse leaving the area while button is down
             area.addEventListener('mouseleave', () => {
                 // If we want dragging to stop when leaving, uncomment below:
                 // if (activeControlArea === area) {
                 //     handleWindowMouseUp();
                 // }
             });
         });

        // Initialize Perception Slider (moved from initializeControls)
        function initializePerceptionSlider() {
            perceptionSlider.min = 10;
            perceptionSlider.max = 300;
            perceptionSlider.step = 5;
            perceptionSlider.value = PERCEPTION_RADIUS;
            valueDisplays.perception.textContent = PERCEPTION_RADIUS;
            perceptionSlider.addEventListener('input', (e) => {
                PERCEPTION_RADIUS = parseFloat(e.target.value);
                valueDisplays.perception.textContent = PERCEPTION_RADIUS;
            });
        }

         // Function to set initial indicator positions and values
         function initializeControlDisplays() {
             // Map initial values back to positions (0-1 range)
             const initialNormX_Flock = mapRange(ALIGNMENT_WEIGHT, -3.0, 3.0, 0, 1);
             const initialNormY_Flock = mapRange(COHESION_WEIGHT, -3.0, 3.0, 0, 1);
             const initialNormX_Forces = mapRange(SEPARATION_WEIGHT, -3.0, 3.0, 0, 1);
             const initialNormY_Forces = mapRange(MAX_FORCE, 0.01, 0.5, 0, 1);
             const initialNormX_Speed = mapRange(MAX_SPEED, 0.5, 10.0, 0, 1);
             const initialNormY_Speed = mapRange(LEADER_FOLLOW_WEIGHT, 0, 4.0, 0, 1);

             // Flock Shape
             indicators.flockShape.style.left = `${initialNormX_Flock * controlAreas.flockShape.offsetWidth}px`;
             indicators.flockShape.style.top = `${(1 - initialNormY_Flock) * controlAreas.flockShape.offsetHeight}px`; // Invert Y for display
             valueDisplays.alignment.textContent = ALIGNMENT_WEIGHT.toFixed(1);
             valueDisplays.cohesion.textContent = COHESION_WEIGHT.toFixed(1);

             // Forces
             indicators.forces.style.left = `${initialNormX_Forces * controlAreas.forces.offsetWidth}px`;
             indicators.forces.style.top = `${(1 - initialNormY_Forces) * controlAreas.forces.offsetHeight}px`;
             valueDisplays.separation.textContent = SEPARATION_WEIGHT.toFixed(1);
             valueDisplays.maxForce.textContent = MAX_FORCE.toFixed(2);

             // Speed/Follow
             indicators.speedFollow.style.left = `${initialNormX_Speed * controlAreas.speedFollow.offsetWidth}px`;
             indicators.speedFollow.style.top = `${(1 - initialNormY_Speed) * controlAreas.speedFollow.offsetHeight}px`;
             valueDisplays.maxSpeed.textContent = MAX_SPEED.toFixed(1);
             valueDisplays.leaderFollow.textContent = LEADER_FOLLOW_WEIGHT.toFixed(1);

             // Perception (from slider setup)
             valueDisplays.perception.textContent = PERCEPTION_RADIUS;
         }


        // --- Main Setup ---
        const container = document.getElementById('boid-container');
        const progressBarContainer = document.getElementById('leader-progress-bar');
        const progressRed = document.getElementById('progress-red');
        const progressBlue = document.getElementById('progress-blue');
        // *** Get both audio elements ***
        const audioDay = document.getElementById('music-day');
        const audioNight = document.getElementById('music-night');
        const boids = [];
        const leaderBoids = [];
        const expressionClasses = ['boid-expression-neutral', 'boid-expression-happy', 'boid-expression-sad'];
        // *** Use a flag to track if user interaction enabled audio ***
        let canPlayAudio = false;
        let clickListenerAdded = false; // To avoid adding multiple listeners

        // Create Boids
        for (let i = 0; i < NUM_BOIDS; i++) {
             // *** Create 3 leaders ***
             const isLeader = (i < 3); // First 3 are leaders

            const wrapper = document.createElement('div');
            wrapper.className = 'boid-wrapper';
            if (isLeader) wrapper.classList.add('leader');

            const bird = document.createElement('div');
            bird.className = 'boid-bird boid-expression-neutral';

            // Add Face Elements
            const eyeLeft = document.createElement('div');
            eyeLeft.className = 'boid-eye boid-eye-left';
            bird.appendChild(eyeLeft);
            const eyeRight = document.createElement('div');
            eyeRight.className = 'boid-eye boid-eye-right';
            bird.appendChild(eyeRight);
            const mouth = document.createElement('div');
            mouth.className = 'boid-mouth';
            bird.appendChild(mouth);

            const ring = document.createElement('div');
            ring.className = 'boid-ring';
            wrapper.appendChild(ring);
            wrapper.appendChild(bird);
            container.appendChild(wrapper);

            const boid = new Boid(
                Math.random() * window.innerWidth,
                Math.random() * window.innerHeight,
                wrapper,
                isLeader
            );
            boids.push(boid); // Add to the main list

            if (isLeader) {
                boid.leaderIndex = leaderBoids.length; // 0, 1, or 2
                // *** Assign Hue based on index ***
                if (boid.leaderIndex === 0) {
                    boid.hue = LEADER_HUE_0; // Red
                } else if (boid.leaderIndex === 1) {
                    boid.hue = LEADER_HUE_1; // Blue
                } else {
                    boid.hue = LEADER_HUE_2; // Green
                    ring.style.borderTopColor = `hsl(${LEADER_HUE_2}, 100%, 50%)`; // Style green leader ring explicitly
                }
                leaderBoids.push(boid); // Add leader to its specific list
            } else {
                 boid.hue = DEFAULT_FOLLOWER_HUE;
                 boid.followingLeaderIndex = -1;
            }
        }

        // Initialize Controls and Displays
        initializePerceptionSlider();
        initializeControlDisplays(); // Call this after elements are in DOM

        // --- Hue Flashing Animation (Unchanged) ---
        let isLightVariant = false;
        boids.forEach(b => {
            if (b.birdElement) {
                // Use the boid's current hue (fixed for leaders, default for followers)
                b.birdElement.style.backgroundColor = `hsl(${b.hue}, 100%, 50%)`;
            }
        });

        function flapWings() {
            const lightness = isLightVariant ? '50%' : '80%';
            boids.forEach(b => {
                if (b.birdElement) {
                    // *** Update color using the boid's CURRENT hue ***
                    b.birdElement.style.backgroundColor = `hsl(${b.hue}, 100%, ${lightness})`;
                }
            });
            isLightVariant = !isLightVariant;
        }
        setInterval(flapWings, 200);

        // --- Function to Update Boid Expressions ---
        function updateBoidExpressions(mood) {
             const newClass = `boid-expression-${mood}`;
             boids.forEach(boid => {
                 // Remove existing expression classes
                 boid.birdElement.classList.remove(...expressionClasses);
                 // Add the new one
                 boid.birdElement.classList.add(newClass);
             });
         }

        // --- Audio Functions ---

        // Attempts to play the correct audio track based on the current background
        function tryPlayCurrentAudio() {
            const currentAudio = (currentBackgroundIndex === 0) ? audioDay : audioNight;
            const otherAudio = (currentBackgroundIndex === 0) ? audioNight : audioDay;

            if (currentAudio) {
                // Pause the other track first
                if (otherAudio && !otherAudio.paused) {
                     otherAudio.pause();
                     // Optional: Reset playback position of paused track
                     // otherAudio.currentTime = 0;
                }

                // Attempt to play the current track
                currentAudio.play().then(() => {
                    canPlayAudio = true; // Mark that playback is allowed
                    console.log(`Playing ${currentBackgroundIndex === 0 ? 'day' : 'night'} music.`);
                    // Remove the click listener if it was added and playback succeeded
                    if (clickListenerAdded) {
                        document.body.removeEventListener('click', handleInteractionEnableAudio);
                        clickListenerAdded = false;
                    }
                }).catch(error => {
                    // This catch might trigger on initial load if autoplay fails,
                    // or later if there's an issue playing the *other* track after interaction.
                    if (!canPlayAudio) {
                        console.warn("Autoplay prevented. Click the page to enable audio.", error);
                        // Add the click listener only if it hasn't been added yet
                        if (!clickListenerAdded) {
                             document.body.addEventListener('click', handleInteractionEnableAudio);
                             clickListenerAdded = true;
                        }
                    } else {
                        // If we already know we *can* play, this is a different error
                        console.error(`Error playing ${currentBackgroundIndex === 0 ? 'day' : 'night'} audio:`, error);
                    }
                });
            }
        }

        // Click handler to enable audio playback after user interaction
        function handleInteractionEnableAudio() {
             console.log("User interaction detected, attempting to enable audio.");
             // Once clicked, try playing the *currently appropriate* audio again.
             // The promise resolution in tryPlayCurrentAudio will set canPlayAudio
             // and remove this listener upon success.
             tryPlayCurrentAudio();
             // No immediate need to remove listener here, success/failure handles it.
        }

        // --- Background Switching Function ---
        function switchBackgroundImage() {
            const previousAudio = (currentBackgroundIndex === 0) ? audioDay : audioNight;

            // Determine next index
            currentBackgroundIndex = (currentBackgroundIndex + 1) % BACKGROUND_IMAGES.length;
            const nextImage = BACKGROUND_IMAGES[currentBackgroundIndex];
            const nextAudio = (currentBackgroundIndex === 0) ? audioDay : audioNight;

            // Pause previous audio immediately
             if (previousAudio && !previousAudio.paused) {
                 previousAudio.pause();
                 // Optional: Reset playback position
                 // previousAudio.currentTime = 0;
             }

            // Preload and set the next image
            const img = new Image();
            img.onload = () => {
                 document.body.style.backgroundImage = `url('${nextImage}')`;
                 console.log(`Switched background to index: ${currentBackgroundIndex} (${nextImage})`);
                 // *** Try to play the NEW audio track AFTER image loads ***
                 // Only attempt play if user has interacted or initial autoplay worked
                 if (canPlayAudio && nextAudio) {
                      nextAudio.play().catch(error => {
                         // Log errors even after initial interaction, in case something goes wrong
                         console.error(`Error switching to ${currentBackgroundIndex === 0 ? 'day' : 'night'} audio:`, error);
                      });
                 } else if (!canPlayAudio) {
                     console.log("Audio not enabled yet, waiting for user interaction to play next track.");
                 }
            };
             img.onerror = () => {
                 console.error(`Failed to load background image: ${nextImage}`);
             };
            img.src = nextImage;
        }

        // --- Animation Loop ---
        function animate() {
            // --- Boid Update Loop ---
            let redFollowers = 0;
            let blueFollowers = 0;
            let greenFollowers = 0; // Added counter
            const totalFollowers = NUM_BOIDS - leaderBoids.length; // Now accounts for 3 leaders

            boids.forEach(boid => {
                let totalForce = { x: 0, y: 0 };
                const mouseTarget = { x: mouseX, y: mouseY };

                if (!boid.isLeader) {
                    // --- Follower Logic ---
                    const nearestLeader = findNearestLeader(boid, leaderBoids);

                    if (nearestLeader) {
                        boid.hue = nearestLeader.hue;
                        boid.followingLeaderIndex = nearestLeader.leaderIndex;
                        // *** Count followers for each leader ***
                        if (nearestLeader.leaderIndex === 0) redFollowers++;
                        else if (nearestLeader.leaderIndex === 1) blueFollowers++;
                        else if (nearestLeader.leaderIndex === 2) greenFollowers++; // Count green
                    } else {
                        boid.hue = DEFAULT_FOLLOWER_HUE;
                        boid.followingLeaderIndex = -1;
                    }

                    const flockingForce = boid.calculateFlockingForces(boids.filter(other => other !== boid && !other.isLeader)); // Followers flock with followers+leaders
                    totalForce = Vector.add(totalForce, flockingForce);
                    const followForce = boid.followLeaderForce(nearestLeader);
                    totalForce = Vector.add(totalForce, followForce);

                } else {
                    // --- Leader Logic ---
                    if (boid.leaderIndex === 0) { // Red Leader (Seeker)
                        const seekForce = boid.calculateSeekForce(mouseTarget);
                        totalForce = Vector.add(totalForce, seekForce);
                        // Optional: Add slight repulsion from other leaders?
                        // const repulsion = boid.calculateLeaderRepulsionForce(leaderBoids);
                        // totalForce = Vector.add(totalForce, Vector.multiply(repulsion, 0.2));
                    } else if (boid.leaderIndex === 1) { // Blue Leader (Fleer)
                        const fleeForce = boid.calculateSeekForce(mouseTarget);
                        totalForce = Vector.add(totalForce, Vector.multiply(fleeForce, -1));
                         // Optional: Add slight repulsion from other leaders?
                        // const repulsion = boid.calculateLeaderRepulsionForce(leaderBoids);
                        // totalForce = Vector.add(totalForce, Vector.multiply(repulsion, 0.2));
                    } else if (boid.leaderIndex === 2) { // Green Leader (Repelled)
                        // *** Calculate repulsion from Red and Blue leaders ***
                        const repulsionForce = boid.calculateLeaderRepulsionForce(leaderBoids);
                        totalForce = Vector.add(totalForce, repulsionForce);
                        // Optional: Add slight cohesion with followers? Or just wander?
                        // const cohesion = boid.calculateFlockingForces(boids.filter(f => !f.isLeader));
                        // totalForce = Vector.add(totalForce, Vector.multiply(cohesion, 0.1));
                    }
                }

                // Apply forces, update, check edges, display (Unchanged)
                boid.applyForce(totalForce);
                boid.update();
                boid.checkEdges();
                boid.display();
            });

            // --- Progress Bar & Mood Update ---
            let currentMood = 'neutral';
            if (totalFollowers > 0) {
                // Keep Red/Blue progress bar for now
                const redPercent = (redFollowers / totalFollowers) * 100;
                const bluePercent = (blueFollowers / totalFollowers) * 100;
                // Note: Green percentage is implicitly 100 - red - blue

                // Update inner bar widths (Red/Blue only)
                progressRed.style.width = `${redPercent}%`;
                progressBlue.style.width = `${bluePercent}%`;

                // Determine background/mood based on Red vs Blue dominance
                const redBlueTotal = redFollowers + blueFollowers;
                const balanceRatio = (redBlueTotal > 0) ? (redFollowers / redBlueTotal) : 0.5; // Ratio within Red/Blue followers

                const backgroundHue = (1 - balanceRatio) * 240;
                progressBarContainer.style.backgroundColor = `hsl(${backgroundHue}, 70%, 40%)`;

                // Determine Flock Mood (based on Red vs Blue)
                const moodThreshold = 0.1;
                 // We check dominance within Red/Blue followers specifically
                if (redFollowers > blueFollowers * (1 + moodThreshold * 2)) { // Need > ~60% Red of Red+Blue
                     currentMood = 'happy';
                } else if (blueFollowers > redFollowers * (1 + moodThreshold * 2)) { // Need > ~60% Blue of Red+Blue
                     currentMood = 'sad';
                } else {
                     currentMood = 'neutral'; // Roughly balanced Red/Blue or dominated by Green
                 }

            } else {
                // Handle case with no followers
                progressRed.style.width = `50%`; // Or maybe 33%? Let's keep 50/50 for now
                progressBlue.style.width = `50%`;
                progressBarContainer.style.backgroundColor = `hsl(120, 50%, 50%)`;
                currentMood = 'neutral';
            }

            // --- Update Boid Expressions ---
            updateBoidExpressions(currentMood);

            requestAnimationFrame(animate); // Loop
        }

        // Start the animation
        initializeControlDisplays();
        updateBoidExpressions('neutral');

        // Set initial background
        document.body.style.backgroundImage = `url('${BACKGROUND_IMAGES[currentBackgroundIndex]}')`; // Start with day bg

        // *** Attempt to play the INITIAL (day) audio on load ***
        tryPlayCurrentAudio(); // This will add the click listener if autoplay fails

        // Start background switching interval
        setInterval(switchBackgroundImage, BACKGROUND_SWITCH_INTERVAL_MS);

        animate(); // Start the main animation

    </script>

</body>
</html>
