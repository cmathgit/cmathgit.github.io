<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber Western Chess</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @keyframes neonPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes pieceMove {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes capture {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(0.5); opacity: 0.5; }
            100% { transform: rotate(360deg) scale(0); opacity: 0; }
        }

        @keyframes boardFlip {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(180deg); }
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a0033 0%, #330011 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #ff00ff;
            overflow-x: hidden;
        }

        .title {
            text-align: center;
            margin: 10px 0;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            text-shadow: 0 0 20px #ff00ff, 0 0 40px #00ffff;
            animation: neonPulse 2s infinite;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ffff00);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .game-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
            justify-content: center;
            padding: 0 10px;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            border: 2px solid #ffff00;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            font-size: clamp(0.8rem, 2vw, 1rem);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
        }

        .board-container {
            perspective: 1000px;
            padding: 10px;
        }

        .board {
            width: min(90vw, 90vh);
            height: min(90vw, 90vh);
            max-width: 500px;
            max-height: 500px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 3px solid #ffff00;
            box-shadow: 0 0 30px #ff00ff, inset 0 0 30px #00ffff;
            background: #000;
            transition: transform 0.5s;
            transform-style: preserve-3d;
        }

        .board.flipping {
            animation: boardFlip 0.5s ease-in-out;
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
        }

        .square.light {
            background: linear-gradient(135deg, #4a0080 0%, #6a00b0 100%);
        }

        .square.dark {
            background: linear-gradient(135deg, #1a0033 0%, #2a0044 100%);
        }

        .square.selected {
            box-shadow: inset 0 0 20px #ffff00;
            background: linear-gradient(135deg, #ffff00 0%, #ff00ff 100%) !important;
        }

        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: radial-gradient(circle, #00ffff 0%, transparent 70%);
            border-radius: 50%;
            animation: neonPulse 1s infinite;
        }

        .square.possible-capture::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            border: 3px solid #ff0000;
            border-radius: 50%;
            animation: neonPulse 0.5s infinite;
        }

        .piece {
            font-size: clamp(2rem, 6vw, 3rem);
            user-select: none;
            transition: all 0.3s;
            filter: drop-shadow(0 0 5px currentColor);
            cursor: grab;
        }

        .piece.moving {
            animation: pieceMove 0.5s ease-in-out;
        }

        .piece.capturing {
            animation: capture 0.5s ease-in-out forwards;
        }

        .piece.white {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .piece.black {
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }

        .status {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffff00;
            border-radius: 5px;
            min-width: 250px;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
        }

        .promotion-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a0033 0%, #330011 100%);
            border: 3px solid #ffff00;
            padding: 20px;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px #ff00ff;
        }

        .promotion-modal.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .promotion-pieces {
            display: flex;
            gap: 10px;
        }

        .promotion-piece {
            font-size: 3rem;
            cursor: pointer;
            transition: transform 0.3s;
            filter: drop-shadow(0 0 10px currentColor);
        }

        .promotion-piece:hover {
            transform: scale(1.2);
        }

        @media (max-width: 600px) {
            .board {
                width: 95vw;
                height: 95vw;
            }
        }
    </style>
</head>
<body>
    <h1 class="title">⚡ CYBER WESTERN CHESS ⚡</h1>
    
    <div class="game-controls">
        <button onclick="newGame()">New Game</button>
        <button onclick="toggleMode()">Mode: <span id="mode">vs Computer</span></button>
        <button onclick="undoMove()">Undo</button>
    </div>

    <div class="status" id="status">White's turn - Choose your destiny</div>

    <div class="board-container">
        <div class="board" id="board"></div>
    </div>

    <div class="promotion-modal" id="promotionModal">
        <div>Choose your champion:</div>
        <div class="promotion-pieces" id="promotionPieces"></div>
    </div>

    <script>
        // Chess pieces with western-themed Unicode
        const PIECES = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        let board = [];
        let selectedSquare = null;
        let currentPlayer = 'white';
        let moveHistory = [];
        let gameMode = 'computer'; // 'computer' or 'twoplayer'
        let isFlipping = false;
        let enPassantTarget = null;
        let castlingRights = {
            white: { kingside: true, queenside: true },
            black: { kingside: true, queenside: true }
        };

        function initBoard() {
            board = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];
        }

        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () => handleSquareClick(row, col);
                    
                    const piece = board[row][col];
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = 'piece ' + (piece === piece.toUpperCase() ? 'white' : 'black');
                        pieceEl.textContent = PIECES[piece];
                        square.appendChild(pieceEl);
                    }
                    
                    boardEl.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            if (isFlipping) return;
            
            if (selectedSquare) {
                const [fromRow, fromCol] = selectedSquare;
                if (isValidMove(fromRow, fromCol, row, col)) {
                    makeMove(fromRow, fromCol, row, col);
                } else {
                    clearSelection();
                    selectSquare(row, col);
                }
            } else {
                selectSquare(row, col);
            }
        }

        function selectSquare(row, col) {
            const piece = board[row][col];
            if (!piece) return;
            
            const isWhitePiece = piece === piece.toUpperCase();
            if ((currentPlayer === 'white' && !isWhitePiece) || 
                (currentPlayer === 'black' && isWhitePiece)) return;
            
            clearSelection();
            selectedSquare = [row, col];
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            square.classList.add('selected');
            
            showPossibleMoves(row, col);
        }

        function showPossibleMoves(fromRow, fromCol) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isValidMove(fromRow, fromCol, row, col)) {
                        const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                        if (board[row][col]) {
                            square.classList.add('possible-capture');
                        } else {
                            square.classList.add('possible-move');
                        }
                    }
                }
            }
        }

        function clearSelection() {
            selectedSquare = null;
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'possible-move', 'possible-capture');
            });
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return false;
            
            const isWhite = piece === piece.toUpperCase();
            const targetPiece = board[toRow][toCol];
            
            // Can't capture own piece
            if (targetPiece && ((targetPiece === targetPiece.toUpperCase()) === isWhite)) {
                return false;
            }
            
            // Check if move would leave king in check
            const tempBoard = board.map(row => [...row]);
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = null;
            
            if (isKingInCheck(isWhite)) {
                board = tempBoard;
                return false;
            }
            board = tempBoard;
            
            const pieceType = piece.toLowerCase();
            const rowDiff = toRow - fromRow;
            const colDiff = Math.abs(toCol - fromCol);
            
            switch (pieceType) {
                case 'p':
                    return isValidPawnMove(fromRow, fromCol, toRow, toCol, isWhite);
                case 'r':
                    return isValidRookMove(fromRow, fromCol, toRow, toCol);
                case 'n':
                    return isValidKnightMove(fromRow, fromCol, toRow, toCol);
                case 'b':
                    return isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case 'q':
                    return isValidQueenMove(fromRow, fromCol, toRow, toCol);
                case 'k':
                    return isValidKingMove(fromRow, fromCol, toRow, toCol, isWhite);
            }
            
            return false;
        }

        function isValidPawnMove(fromRow, fromCol, toRow, toCol, isWhite) {
            const direction = isWhite ? -1 : 1;
            const startRow = isWhite ? 6 : 1;
            const rowDiff = toRow - fromRow;
            const colDiff = Math.abs(toCol - fromCol);
            
            // Forward move
            if (colDiff === 0) {
                if (rowDiff === direction && !board[toRow][toCol]) return true;
                if (fromRow === startRow && rowDiff === 2 * direction && 
                    !board[toRow][toCol] && !board[fromRow + direction][fromCol]) return true;
            }
            
            // Diagonal capture
            if (colDiff === 1 && rowDiff === direction) {
                if (board[toRow][toCol]) return true;
                // En passant
                if (enPassantTarget && enPassantTarget[0] === toRow && enPassantTarget[1] === toCol) {
                    return true;
                }
            }
            
            return false;
        }

        function isValidRookMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            return !isPathBlocked(fromRow, fromCol, toRow, toCol);
        }

        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }

        function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
            if (Math.abs(toRow - fromRow) !== Math.abs(toCol - fromCol)) return false;
            return !isPathBlocked(fromRow, fromCol, toRow, toCol);
        }

        function isValidQueenMove(fromRow, fromCol, toRow, toCol) {
            return isValidRookMove(fromRow, fromCol, toRow, toCol) || 
                   isValidBishopMove(fromRow, fromCol, toRow, toCol);
        }

        function isValidKingMove(fromRow, fromCol, toRow, toCol, isWhite) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            
            // Normal king move
            if (rowDiff <= 1 && colDiff <= 1) return true;
            
            // Castling
            if (rowDiff === 0 && colDiff === 2) {
                const rights = isWhite ? castlingRights.white : castlingRights.black;
                const row = isWhite ? 7 : 0;
                
                if (fromRow !== row) return false;
                
                // Kingside
                if (toCol === 6 && rights.kingside) {
                    if (!board[row][5] && !board[row][6] && board[row][7] && 
                        board[row][7].toLowerCase() === 'r') {
                        // Check if squares are under attack
                        for (let col = 4; col <= 6; col++) {
                            if (isSquareUnderAttack(row, col, !isWhite)) return false;
                        }
                        return true;
                    }
                }
                
                // Queenside
                if (toCol === 2 && rights.queenside) {
                    if (!board[row][1] && !board[row][2] && !board[row][3] && 
                        board[row][0] && board[row][0].toLowerCase() === 'r') {
                        // Check if squares are under attack
                        for (let col = 2; col <= 4; col++) {
                            if (isSquareUnderAttack(row, col, !isWhite)) return false;
                        }
                        return true;
                    }
                }
            }
            
            return false;
        }

        function isPathBlocked(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
            
            let row = fromRow + rowStep;
            let col = fromCol + colStep;
            
            while (row !== toRow || col !== toCol) {
                if (board[row][col]) return true;
                row += rowStep;
                col += colStep;
            }
            
            return false;
        }

        function isKingInCheck(isWhite) {
            let kingRow, kingCol;
            const kingPiece = isWhite ? 'K' : 'k';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingPiece) {
                        kingRow = row;
                        kingCol = col;
                        break;
                    }
                }
            }
            
            return isSquareUnderAttack(kingRow, kingCol, !isWhite);
        }

        function isSquareUnderAttack(row, col, byWhite) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (!piece) continue;
                    
                    const isWhitePiece = piece === piece.toUpperCase();
                    if (isWhitePiece !== byWhite) continue;
                    
                    // Temporarily place a piece to check if it can attack
                    const tempBoard = board.map(row => [...row]);
                    const tempPiece = board[row][col];
                    board[row][col] = byWhite ? 'p' : 'P'; // Opposite color pawn for capture check
                    
                    if (isValidMoveIgnoringCheck(r, c, row, col)) {
                        board = tempBoard;
                        return true;
                    }
                    board = tempBoard;
                }
            }
            return false;
        }

        function isValidMoveIgnoringCheck(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return false;
            
            const isWhite = piece === piece.toUpperCase();
            const pieceType = piece.toLowerCase();
            
            switch (pieceType) {
                case 'p':
                    const direction = isWhite ? -1 : 1;
                    const rowDiff = toRow - fromRow;
                    const colDiff = Math.abs(toCol - fromCol);
                    return colDiff === 1 && rowDiff === direction;
                case 'r':
                    return isValidRookMove(fromRow, fromCol, toRow, toCol);
                case 'n':
                    return isValidKnightMove(fromRow, fromCol, toRow, toCol);
                case 'b':
                    return isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case 'q':
                    return isValidQueenMove(fromRow, fromCol, toRow, toCol);
                case 'k':
                    const rDiff = Math.abs(toRow - fromRow);
                    const cDiff = Math.abs(toCol - fromCol);
                    return rDiff <= 1 && cDiff <= 1;
            }
            
            return false;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            const isWhite = piece === piece.toUpperCase();
            
            // Store move for history
            moveHistory.push({
                from: [fromRow, fromCol],
                to: [toRow, toCol],
                piece: piece,
                captured: capturedPiece,
                enPassant: enPassantTarget,
                castlingRights: JSON.parse(JSON.stringify(castlingRights))
            });
            
            // Animate capture
            if (capturedPiece) {
                const captureSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"] .piece`);
                if (captureSquare) {
                    captureSquare.classList.add('capturing');
                }
            }
            
            // Handle en passant capture
            if (piece.toLowerCase() === 'p' && enPassantTarget && 
                enPassantTarget[0] === toRow && enPassantTarget[1] === toCol) {
                const captureRow = isWhite ? toRow + 1 : toRow - 1;
                board[captureRow][toCol] = null;
            }
            
            // Update en passant target
            enPassantTarget = null;
            if (piece.toLowerCase() === 'p' && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = [isWhite ? toRow + 1 : toRow - 1, toCol];
            }
            
            // Handle castling
            if (piece.toLowerCase() === 'k' && Math.abs(toCol - fromCol) === 2) {
                const row = isWhite ? 7 : 0;
                if (toCol === 6) { // Kingside
                    board[row][5] = board[row][7];
                    board[row][7] = null;
                } else if (toCol === 2) { // Queenside
                    board[row][3] = board[row][0];
                    board[row][0] = null;
                }
            }
            
            // Update castling rights
            if (piece.toLowerCase() === 'k') {
                if (isWhite) {
                    castlingRights.white.kingside = false;
                    castlingRights.white.queenside = false;
                } else {
                    castlingRights.black.kingside = false;
                    castlingRights.black.queenside = false;
                }
            }
            
            if (piece.toLowerCase() === 'r') {
                if (isWhite) {
                    if (fromRow === 7 && fromCol === 0) castlingRights.white.queenside = false;
                    if (fromRow === 7 && fromCol === 7) castlingRights.white.kingside = false;
                } else {
                    if (fromRow === 0 && fromCol === 0) castlingRights.black.queenside = false;
                    if (fromRow === 0 && fromCol === 7) castlingRights.black.kingside = false;
                }
            }
            
            // Move piece
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            
            // Check for pawn promotion
            if (piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                showPromotionModal(toRow, toCol, isWhite);
                return;
            }
            
            // Animate move
            setTimeout(() => {
                renderBoard();
                const movedPiece = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"] .piece`);
                if (movedPiece) {
                    movedPiece.classList.add('moving');
                }
            }, capturedPiece ? 500 : 0);
            
            clearSelection();
            endTurn();
        }

        function showPromotionModal(row, col, isWhite) {
            const modal = document.getElementById('promotionModal');
            const piecesContainer = document.getElementById('promotionPieces');
            
            const pieces = isWhite ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
            piecesContainer.innerHTML = '';
            
            pieces.forEach(piece => {
                const pieceEl = document.createElement('div');
                pieceEl.className = 'promotion-piece ' + (isWhite ? 'white' : 'black');
                pieceEl.textContent = PIECES[piece];
                pieceEl.onclick = () => {
                    board[row][col] = piece;
                    modal.classList.remove('active');
                    renderBoard();
                    endTurn();
                };
                piecesContainer.appendChild(pieceEl);
            });
            
            modal.classList.add('active');
        }

        function endTurn() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            updateStatus();
            
            if (gameMode === 'twoplayer') {
                flipBoard();
            } else if (gameMode === 'computer' && currentPlayer === 'black') {
                setTimeout(makeComputerMove, 500);
            }
        }

        function flipBoard() {
            if (gameMode !== 'twoplayer') return;
            
            isFlipping = true;
            const boardEl = document.getElementById('board');
            boardEl.classList.add('flipping');
            
            setTimeout(() => {
                board = board.reverse().map(row => row.reverse());
                renderBoard();
                boardEl.classList.remove('flipping');
                isFlipping = false;
            }, 500);
        }

        function makeComputerMove() {
            const moves = getAllValidMoves('black');
            if (moves.length === 0) {
                updateStatus();
                return;
            }
            
            // Simple AI: prioritize captures, then random
            const captureMoves = moves.filter(m => board[m.to[0]][m.to[1]]);
            const selectedMove = captureMoves.length > 0 ? 
                captureMoves[Math.floor(Math.random() * captureMoves.length)] :
                moves[Math.floor(Math.random() * moves.length)];
            
            makeMove(selectedMove.from[0], selectedMove.from[1], 
                    selectedMove.to[0], selectedMove.to[1]);
        }

        function getAllValidMoves(color) {
            const moves = [];
            const isWhite = color === 'white';
            
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (!piece) continue;
                    
                    const pieceIsWhite = piece === piece.toUpperCase();
                    if (pieceIsWhite !== isWhite) continue;
                    
                    for (let toRow = 0; toRow < 8; toRow++) {
                        for (let toCol = 0; toCol < 8; toCol++) {
                            if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                moves.push({
                                    from: [fromRow, fromCol],
                                    to: [toRow, toCol]
                                });
                            }
                        }
                    }
                }
            }
            
            return moves;
        }

        function updateStatus() {
            const status = document.getElementById('status');
            const inCheck = isKingInCheck(currentPlayer === 'white');
            const moves = getAllValidMoves(currentPlayer);
            
            if (moves.length === 0) {
                if (inCheck) {
                    status.textContent = `Checkmate! ${currentPlayer === 'white' ? 'Black' : 'White'} wins!`;
                    status.style.color = '#